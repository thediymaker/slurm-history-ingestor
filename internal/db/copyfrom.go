// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: copyfrom.go

package db

import (
	"context"
)

// iteratorForBatchInsertHistory implements pgx.CopyFromSource.
type iteratorForBatchInsertHistory struct {
	rows                 []BatchInsertHistoryParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchInsertHistory) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchInsertHistory) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].JobID,
		r.rows[0].Cluster,
		r.rows[0].UserID,
		r.rows[0].AccountID,
		r.rows[0].Partition,
		r.rows[0].Qos,
		r.rows[0].JobState,
		r.rows[0].ExitCode,
		r.rows[0].DerivedExitState,
		r.rows[0].ReqCpus,
		r.rows[0].ReqNodes,
		r.rows[0].ReqMemMc,
		r.rows[0].MaxRss,
		r.rows[0].NodeList,
		r.rows[0].SubmitTime,
		r.rows[0].StartTime,
		r.rows[0].EndTime,
		r.rows[0].WaitTimeSeconds,
		r.rows[0].RunTimeSeconds,
		r.rows[0].CoreHours,
		r.rows[0].JobName,
		r.rows[0].TresAllocStr,
		r.rows[0].TresReqStr,
		r.rows[0].ArrayJobID,
		r.rows[0].ArrayTaskID,
		r.rows[0].GroupName,
		r.rows[0].EligibleTime,
		r.rows[0].TimelimitMinutes,
	}, nil
}

func (r iteratorForBatchInsertHistory) Err() error {
	return nil
}

func (q *Queries) BatchInsertHistory(ctx context.Context, arg []BatchInsertHistoryParams) (int64, error) {
	// 1. Drop and recreate temp table to ensure clean state
	// Using DROP + CREATE instead of IF NOT EXISTS + TRUNCATE to avoid stale schema issues
	_, err := q.db.Exec(ctx, `DROP TABLE IF EXISTS job_history_temp`)
	if err != nil {
		return 0, err
	}
	
	// Create temp table with same structure but NO constraints (no primary key)
	_, err = q.db.Exec(ctx, `CREATE TEMP TABLE job_history_temp (LIKE job_history INCLUDING DEFAULTS)`)
	if err != nil {
		return 0, err
	}

	// 2. Copy to Temp Table
	// Note: We use the same columns as defined in the original CopyFrom
	count, err := q.db.CopyFrom(ctx, []string{"job_history_temp"}, []string{"job_id", "cluster", "user_id", "account_id", "partition", "qos", "job_state", "exit_code", "derived_exit_state", "req_cpus", "req_nodes", "req_mem_mc", "max_rss", "node_list", "submit_time", "start_time", "end_time", "wait_time_seconds", "run_time_seconds", "core_hours", "job_name", "tres_alloc_str", "tres_req_str", "array_job_id", "array_task_id", "group_name", "eligible_time", "timelimit_minutes"}, &iteratorForBatchInsertHistory{rows: arg})
	if err != nil {
		return 0, err
	}

	// 3. Upsert from Temp to Main
	// We use ON CONFLICT DO UPDATE to ensure latest state is captured (e.g. job finished)
	query := `
        INSERT INTO job_history (
            job_id, cluster, user_id, account_id, partition, qos,
            job_state, exit_code, derived_exit_state, req_cpus, req_nodes, req_mem_mc,
            max_rss, node_list, submit_time, start_time, end_time,
            wait_time_seconds, run_time_seconds, core_hours,
            job_name, tres_alloc_str, tres_req_str, array_job_id, array_task_id, group_name, eligible_time, timelimit_minutes
        )
        SELECT 
            job_id, cluster, user_id, account_id, partition, qos,
            job_state, exit_code, derived_exit_state, req_cpus, req_nodes, req_mem_mc,
            max_rss, node_list, submit_time, start_time, end_time,
            wait_time_seconds, run_time_seconds, core_hours,
            job_name, tres_alloc_str, tres_req_str, array_job_id, array_task_id, group_name, eligible_time, timelimit_minutes
        FROM job_history_temp
        ON CONFLICT (job_id, cluster, submit_time) 
        DO UPDATE SET
            job_state = EXCLUDED.job_state,
            exit_code = EXCLUDED.exit_code,
            end_time = EXCLUDED.end_time,
            run_time_seconds = EXCLUDED.run_time_seconds,
            core_hours = EXCLUDED.core_hours,
            wait_time_seconds = EXCLUDED.wait_time_seconds,
            job_name = EXCLUDED.job_name,
            tres_alloc_str = EXCLUDED.tres_alloc_str,
            tres_req_str = EXCLUDED.tres_req_str,
            array_job_id = EXCLUDED.array_job_id,
            array_task_id = EXCLUDED.array_task_id,
            group_name = EXCLUDED.group_name,
            eligible_time = EXCLUDED.eligible_time,
            timelimit_minutes = EXCLUDED.timelimit_minutes
    `
	_, err = q.db.Exec(ctx, query)
	if err != nil {
		return 0, err
	}

	return count, nil
}
